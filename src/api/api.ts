/* tslint:disable */
/* eslint-disable */
/**
 * ExamSphere API
 * This is the API for the ExamSphere system
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const APIErrorCode = {
    ErrCodeMalformedJWT: 2100,
    ErrCodeInvalidJWT: 2101,
    ErrCodeInvalidBodyData: 2102,
    ErrCodeInvalidUsernamePass: 2103,
    ErrCodeInvalidAuth: 2104,
    ErrCodePermissionDenied: 2105,
    ErrCodeInvalidInputPass: 2106,
    ErrCodeUsernameExists: 2107,
    ErrCodeInternalServerError: 2108,
    ErrCodeInvalidFileData: 2109,
    ErrCodeInvalidPhoneNumber: 2110,
    ErrCodePhoneNumberAlreadyImported: 2111,
    ErrCodeInvalidUserID: 2112,
    ErrCodeNoPhonesDonated: 2113,
    ErrCodeAgentNotConnected: 2114,
    ErrCodeInvalidPagination: 2115,
    ErrCodeMaxContactImportLimit: 2116,
    ErrCodePhoneNumberNotFound: 2117,
    ErrCodeParameterRequired: 2118,
    ErrCodeUserBanned: 2119,
    ErrCodeLabelInfoNotFound: 2120,
    ErrCodeLabelAlreadyApplied: 2121,
    ErrCodeLabelAlreadyExistsByName: 2122,
    ErrCodeTooManyChatLabelInfo: 2123,
    ErrCodeLabelNameTooLong: 2124,
    ErrCodeLabelDescriptionTooLong: 2125,
    ErrCodeInvalidColor: 2126,
    ErrCodeLabelNotApplied: 2127,
    ErrCodeCannotDeleteBuiltInLabel: 2128,
    ErrCodeDuplicatePhoneNumber: 2129,
    ErrCodePhoneNotWorking: 2130,
    ErrCodeInvalidPmsPass: 2131,
    ErrCodeInvalidAgentId: 2132,
    ErrCodeInvalidAppSettingName: 2133,
    ErrCodeAppSettingNotFound: 2134,
    ErrCodeTextEmpty: 2135,
    ErrCodeTextTooLong: 2136,
    ErrCodeInvalidClientRId: 2137,
    ErrCodeInvalidCaptcha: 2138,
    ErrCodeQueryParameterNotProvided: 2139,
    ErrCodeTooManyPasswordChangeAttempts: 2140,
    ErrCodeRequestExpired: 2141,
    ErrCodeInvalidEmail: 2142,
    ErrCodeCourseAlreadyExists: 2143,
    ErrCodeCourseNotFound: 2144,
    ErrCodeExamNotFound: 2145,
    ErrCodeNotParticipatedInExam: 2146,
    ErrCodeExamNotStarted: 2147,
    ErrCodeExamFinished: 2148,
    ErrCodeExamQuestionNotFound: 2149,
    ErrCodeInvalidAnswerOption: 2150,
    ErrCodeGivenExamNotFound: 2151,
    ErrCodeAccountAlreadyConfirmed: 2152,
    ErrCodeEmailAlreadyExists: 2153,
    ErrCodeTopicNameExists: 2154,
    ErrCodeTopicNotFound: 2155,
    ErrCodeBodyTooLong: 2156
} as const;

export type APIErrorCode = typeof APIErrorCode[keyof typeof APIErrorCode];


/**
 * 
 * @export
 * @interface AnswerExamQuestionV1200Response
 */
export interface AnswerExamQuestionV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof AnswerExamQuestionV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {AnswerQuestionResult}
     * @memberof AnswerExamQuestionV1200Response
     */
    'result'?: AnswerQuestionResult;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerExamQuestionV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface AnswerQuestionData
 */
export interface AnswerQuestionData {
    /**
     * 
     * @type {string}
     * @memberof AnswerQuestionData
     */
    'answer_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerQuestionData
     */
    'chosen_option'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnswerQuestionData
     */
    'exam_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnswerQuestionData
     */
    'question_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnswerQuestionData
     */
    'seconds_taken'?: number;
}
/**
 * 
 * @export
 * @interface AnswerQuestionResult
 */
export interface AnswerQuestionResult {
    /**
     * 
     * @type {string}
     * @memberof AnswerQuestionResult
     */
    'answered_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerQuestionResult
     */
    'answered_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnswerQuestionResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnswerQuestionResult
     */
    'question_id'?: number;
}
/**
 * 
 * @export
 * @interface AnsweredQuestionInfo
 */
export interface AnsweredQuestionInfo {
    /**
     * 
     * @type {string}
     * @memberof AnsweredQuestionInfo
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnsweredQuestionInfo
     */
    'chosen_option'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnsweredQuestionInfo
     */
    'question_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsweredQuestionInfo
     */
    'seconds_taken'?: number;
}
/**
 * 
 * @export
 * @interface AuthResult
 */
export interface AuthResult {
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthResult
     */
    'expiration'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface BanUserData
 */
export interface BanUserData {
    /**
     * 
     * @type {string}
     * @memberof BanUserData
     */
    'ban_reason'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BanUserData
     */
    'is_banned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BanUserData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface BanUserResult
 */
export interface BanUserResult {
    /**
     * 
     * @type {string}
     * @memberof BanUserResult
     */
    'ban_reason'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BanUserResult
     */
    'is_banned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BanUserResult
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface BanUserV1200Response
 */
export interface BanUserV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof BanUserV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {BanUserResult}
     * @memberof BanUserV1200Response
     */
    'result'?: BanUserResult;
    /**
     * 
     * @type {boolean}
     * @memberof BanUserV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CaptchaHandlersGetCaptchaResult
 */
export interface CaptchaHandlersGetCaptchaResult {
    /**
     * 
     * @type {string}
     * @memberof CaptchaHandlersGetCaptchaResult
     */
    'captcha'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaptchaHandlersGetCaptchaResult
     */
    'captcha_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CaptchaHandlersGetCaptchaResult
     */
    'client_r_id'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordData
 */
export interface ChangePasswordData {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordData
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordData
     */
    'new_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordResult
 */
export interface ChangePasswordResult {
    /**
     * 
     * @type {boolean}
     * @memberof ChangePasswordResult
     */
    'email_sent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordResult
     */
    'lang'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChangePasswordResult
     */
    'password_changed'?: boolean;
}
/**
 * 
 * @export
 * @interface ChangePasswordV1200Response
 */
export interface ChangePasswordV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof ChangePasswordV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {ChangePasswordResult}
     * @memberof ChangePasswordV1200Response
     */
    'result'?: ChangePasswordResult;
    /**
     * 
     * @type {boolean}
     * @memberof ChangePasswordV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfirmAccountData
 */
export interface ConfirmAccountData {
    /**
     * 
     * @type {string}
     * @memberof ConfirmAccountData
     */
    'confirm_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmAccountData
     */
    'lt_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmAccountData
     */
    'raw_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmAccountData
     */
    'rl_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmAccountData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface ConfirmChangePasswordData
 */
export interface ConfirmChangePasswordData {
    /**
     * 
     * @type {string}
     * @memberof ConfirmChangePasswordData
     */
    'new_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmChangePasswordData
     */
    'rq_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmChangePasswordData
     */
    'rt_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmChangePasswordData
     */
    'rt_param'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmChangePasswordData
     */
    'rt_verifier'?: string;
}
/**
 * 
 * @export
 * @interface CourseParticipantInfo
 */
export interface CourseParticipantInfo {
    /**
     * 
     * @type {string}
     * @memberof CourseParticipantInfo
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseParticipantInfo
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface CreateCourseData
 */
export interface CreateCourseData {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseData
     */
    'course_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseData
     */
    'course_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseData
     */
    'topic_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateCourseResult
 */
export interface CreateCourseResult {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseResult
     */
    'added_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseResult
     */
    'course_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseResult
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseResult
     */
    'course_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCourseResult
     */
    'topic_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateCourseV1200Response
 */
export interface CreateCourseV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof CreateCourseV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {CreateCourseResult}
     * @memberof CreateCourseV1200Response
     */
    'result'?: CreateCourseResult;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCourseV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateExamData
 */
export interface CreateExamData {
    /**
     * 
     * @type {number}
     * @memberof CreateExamData
     */
    'course_id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateExamData
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateExamData
     */
    'exam_date'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExamData
     */
    'exam_description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamData
     */
    'exam_title': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateExamData
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateExamData
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface CreateExamQuestionData
 */
export interface CreateExamQuestionData {
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionData
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateExamQuestionData
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionData
     */
    'option1'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionData
     */
    'option2'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionData
     */
    'option3'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionData
     */
    'option4'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionData
     */
    'question_title'?: string;
}
/**
 * 
 * @export
 * @interface CreateExamQuestionResult
 */
export interface CreateExamQuestionResult {
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateExamQuestionResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'option1'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'option2'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'option3'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'option4'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateExamQuestionResult
     */
    'question_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExamQuestionResult
     */
    'question_title'?: string;
}
/**
 * 
 * @export
 * @interface CreateExamQuestionV1200Response
 */
export interface CreateExamQuestionV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof CreateExamQuestionV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {CreateExamQuestionResult}
     * @memberof CreateExamQuestionV1200Response
     */
    'result'?: CreateExamQuestionResult;
    /**
     * 
     * @type {boolean}
     * @memberof CreateExamQuestionV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateExamResult
 */
export interface CreateExamResult {
    /**
     * 
     * @type {number}
     * @memberof CreateExamResult
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExamResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExamResult
     */
    'created_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateExamResult
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExamResult
     */
    'exam_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateExamResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateExamResult
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateExamResult
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface CreateExamV1200Response
 */
export interface CreateExamV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof CreateExamV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {CreateExamResult}
     * @memberof CreateExamV1200Response
     */
    'result'?: CreateExamResult;
    /**
     * 
     * @type {boolean}
     * @memberof CreateExamV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateNewTopicData
 */
export interface CreateNewTopicData {
    /**
     * 
     * @type {string}
     * @memberof CreateNewTopicData
     */
    'topic_name'?: string;
}
/**
 * 
 * @export
 * @interface CreateNewTopicResult
 */
export interface CreateNewTopicResult {
    /**
     * 
     * @type {number}
     * @memberof CreateNewTopicResult
     */
    'topic_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateNewTopicResult
     */
    'topic_name'?: string;
}
/**
 * 
 * @export
 * @interface CreateTopicV1200Response
 */
export interface CreateTopicV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof CreateTopicV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {CreateNewTopicResult}
     * @memberof CreateTopicV1200Response
     */
    'result'?: CreateNewTopicResult;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTopicV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateUserData
 */
export interface CreateUserData {
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'primary_language'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof CreateUserData
     */
    'role'?: UserRole;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserData
     */
    'setup_completed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'user_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserData
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface CreateUserResult
 */
export interface CreateUserResult {
    /**
     * 
     * @type {string}
     * @memberof CreateUserResult
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResult
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResult
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResult
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserV1200Response
 */
export interface CreateUserV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof CreateUserV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {CreateUserResult}
     * @memberof CreateUserV1200Response
     */
    'result'?: CreateUserResult;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteTopicV1200Response
 */
export interface DeleteTopicV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof DeleteTopicV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteTopicV1200Response
     */
    'result'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteTopicV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface EditCourseData
 */
export interface EditCourseData {
    /**
     * 
     * @type {string}
     * @memberof EditCourseData
     */
    'course_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditCourseData
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditCourseData
     */
    'course_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditCourseData
     */
    'topic_id'?: number;
}
/**
 * 
 * @export
 * @interface EditCourseResult
 */
export interface EditCourseResult {
    /**
     * 
     * @type {string}
     * @memberof EditCourseResult
     */
    'added_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditCourseResult
     */
    'course_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditCourseResult
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditCourseResult
     */
    'course_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditCourseResult
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface EditCourseV1200Response
 */
export interface EditCourseV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof EditCourseV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {EditCourseResult}
     * @memberof EditCourseV1200Response
     */
    'result'?: EditCourseResult;
    /**
     * 
     * @type {boolean}
     * @memberof EditCourseV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface EditExamData
 */
export interface EditExamData {
    /**
     * 
     * @type {number}
     * @memberof EditExamData
     */
    'course_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditExamData
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof EditExamData
     */
    'exam_date'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamData
     */
    'exam_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamData
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamData
     */
    'exam_title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditExamData
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditExamData
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface EditExamQuestionData
 */
export interface EditExamQuestionData {
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionData
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamQuestionData
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionData
     */
    'option1'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionData
     */
    'option2'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionData
     */
    'option3'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionData
     */
    'option4'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamQuestionData
     */
    'question_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionData
     */
    'question_title'?: string;
}
/**
 * 
 * @export
 * @interface EditExamQuestionResult
 */
export interface EditExamQuestionResult {
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamQuestionResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'option1'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'option2'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'option3'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'option4'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamQuestionResult
     */
    'question_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamQuestionResult
     */
    'question_title'?: string;
}
/**
 * 
 * @export
 * @interface EditExamQuestionV1200Response
 */
export interface EditExamQuestionV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof EditExamQuestionV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {EditExamQuestionResult}
     * @memberof EditExamQuestionV1200Response
     */
    'result'?: EditExamQuestionResult;
    /**
     * 
     * @type {boolean}
     * @memberof EditExamQuestionV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface EditExamResult
 */
export interface EditExamResult {
    /**
     * 
     * @type {number}
     * @memberof EditExamResult
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamResult
     */
    'created_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamResult
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamResult
     */
    'exam_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditExamResult
     */
    'exam_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof EditExamResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EditExamResult
     */
    'exam_title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditExamResult
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditExamResult
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface EditExamV1200Response
 */
export interface EditExamV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof EditExamV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {EditExamResult}
     * @memberof EditExamV1200Response
     */
    'result'?: EditExamResult;
    /**
     * 
     * @type {boolean}
     * @memberof EditExamV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface EditUserData
 */
export interface EditUserData {
    /**
     * 
     * @type {string}
     * @memberof EditUserData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserData
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserData
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserData
     */
    'user_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface EditUserResult
 */
export interface EditUserResult {
    /**
     * 
     * @type {string}
     * @memberof EditUserResult
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserResult
     */
    'full_name'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof EditUserResult
     */
    'role'?: UserRole;
    /**
     * 
     * @type {string}
     * @memberof EditUserResult
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface EditUserV1200Response
 */
export interface EditUserV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof EditUserV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {EditUserResult}
     * @memberof EditUserV1200Response
     */
    'result'?: EditUserResult;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface EndpointError
 */
export interface EndpointError {
    /**
     * 
     * @type {APIErrorCode}
     * @memberof EndpointError
     */
    'code'?: APIErrorCode;
    /**
     * 
     * @type {string}
     * @memberof EndpointError
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof EndpointError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EndpointError
     */
    'origin'?: string;
}


/**
 * 
 * @export
 * @interface EndpointResponse
 */
export interface EndpointResponse {
    /**
     * 
     * @type {EndpointError}
     * @memberof EndpointResponse
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {object}
     * @memberof EndpointResponse
     */
    'result'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof EndpointResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ExamQuestionInfo
 */
export interface ExamQuestionInfo {
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'option1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'option2'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'option3'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'option4'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestionInfo
     */
    'question_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestionInfo
     */
    'question_title'?: string;
    /**
     * 
     * @type {AnsweredQuestionInfo}
     * @memberof ExamQuestionInfo
     */
    'user_answer'?: AnsweredQuestionInfo;
}
/**
 * 
 * @export
 * @interface GenerateCaptchaV1200Response
 */
export interface GenerateCaptchaV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GenerateCaptchaV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {CaptchaHandlersGetCaptchaResult}
     * @memberof GenerateCaptchaV1200Response
     */
    'result'?: CaptchaHandlersGetCaptchaResult;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateCaptchaV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAllUserTopicStatsResult
 */
export interface GetAllUserTopicStatsResult {
    /**
     * 
     * @type {Array<UserTopicStatInfo>}
     * @memberof GetAllUserTopicStatsResult
     */
    'stats'?: Array<UserTopicStatInfo>;
    /**
     * 
     * @type {string}
     * @memberof GetAllUserTopicStatsResult
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface GetAllUserTopicStatsV1200Response
 */
export interface GetAllUserTopicStatsV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetAllUserTopicStatsV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetAllUserTopicStatsResult}
     * @memberof GetAllUserTopicStatsV1200Response
     */
    'result'?: GetAllUserTopicStatsResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetAllUserTopicStatsV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCourseInfoResult
 */
export interface GetCourseInfoResult {
    /**
     * 
     * @type {string}
     * @memberof GetCourseInfoResult
     */
    'added_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCourseInfoResult
     */
    'course_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCourseInfoResult
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCourseInfoResult
     */
    'course_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCourseInfoResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCourseInfoResult
     */
    'topic_id'?: number;
}
/**
 * 
 * @export
 * @interface GetCourseInfoV1200Response
 */
export interface GetCourseInfoV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetCourseInfoV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetCourseInfoResult}
     * @memberof GetCourseInfoV1200Response
     */
    'result'?: GetCourseInfoResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetCourseInfoV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCourseParticipantsData
 */
export interface GetCourseParticipantsData {
    /**
     * 
     * @type {number}
     * @memberof GetCourseParticipantsData
     */
    'course_id'?: number;
}
/**
 * 
 * @export
 * @interface GetCourseParticipantsResult
 */
export interface GetCourseParticipantsResult {
    /**
     * 
     * @type {Array<CourseParticipantInfo>}
     * @memberof GetCourseParticipantsResult
     */
    'participants'?: Array<CourseParticipantInfo>;
}
/**
 * 
 * @export
 * @interface GetCourseParticipantsV1200Response
 */
export interface GetCourseParticipantsV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetCourseParticipantsV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetCourseParticipantsResult}
     * @memberof GetCourseParticipantsV1200Response
     */
    'result'?: GetCourseParticipantsResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetCourseParticipantsV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCreatedCoursesData
 */
export interface GetCreatedCoursesData {
    /**
     * 
     * @type {string}
     * @memberof GetCreatedCoursesData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface GetCreatedCoursesResult
 */
export interface GetCreatedCoursesResult {
    /**
     * 
     * @type {Array<SearchedCourseInfo>}
     * @memberof GetCreatedCoursesResult
     */
    'courses'?: Array<SearchedCourseInfo>;
}
/**
 * 
 * @export
 * @interface GetCreatedCoursesV1200Response
 */
export interface GetCreatedCoursesV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetCreatedCoursesV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetCreatedCoursesResult}
     * @memberof GetCreatedCoursesV1200Response
     */
    'result'?: GetCreatedCoursesResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetCreatedCoursesV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetExamInfoResult
 */
export interface GetExamInfoResult {
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'can_add_others_to_exam'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'can_edit_question'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'can_participate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetExamInfoResult
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetExamInfoResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetExamInfoResult
     */
    'created_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetExamInfoResult
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetExamInfoResult
     */
    'exam_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetExamInfoResult
     */
    'exam_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetExamInfoResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetExamInfoResult
     */
    'exam_title'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetExamInfoResult
     */
    'finishes_in'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'has_finished'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'has_participated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'has_started'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoResult
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetExamInfoResult
     */
    'price'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetExamInfoResult
     */
    'question_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExamInfoResult
     */
    'starts_in'?: number;
}
/**
 * 
 * @export
 * @interface GetExamInfoV1200Response
 */
export interface GetExamInfoV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetExamInfoV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetExamInfoResult}
     * @memberof GetExamInfoV1200Response
     */
    'result'?: GetExamInfoResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamInfoV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetExamQuestionsData
 */
export interface GetExamQuestionsData {
    /**
     * 
     * @type {number}
     * @memberof GetExamQuestionsData
     */
    'exam_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExamQuestionsData
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExamQuestionsData
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface GetExamQuestionsResult
 */
export interface GetExamQuestionsResult {
    /**
     * 
     * @type {number}
     * @memberof GetExamQuestionsResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {Array<ExamQuestionInfo>}
     * @memberof GetExamQuestionsResult
     */
    'questions'?: Array<ExamQuestionInfo>;
}
/**
 * 
 * @export
 * @interface GetExamQuestionsV1200Response
 */
export interface GetExamQuestionsV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetExamQuestionsV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetExamQuestionsResult}
     * @memberof GetExamQuestionsV1200Response
     */
    'result'?: GetExamQuestionsResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetExamQuestionsV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetGivenExamData
 */
export interface GetGivenExamData {
    /**
     * 
     * @type {string}
     * @memberof GetGivenExamData
     */
    'added_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetGivenExamData
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetGivenExamData
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetGivenExamData
     */
    'final_score'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetGivenExamData
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetGivenExamData
     */
    'scored_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetGivenExamData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface GetGivenExamV1200Response
 */
export interface GetGivenExamV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetGivenExamV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetGivenExamData}
     * @memberof GetGivenExamV1200Response
     */
    'result'?: GetGivenExamData;
    /**
     * 
     * @type {boolean}
     * @memberof GetGivenExamV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetMeResult
 */
export interface GetMeResult {
    /**
     * 
     * @type {string}
     * @memberof GetMeResult
     */
    'full_name'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof GetMeResult
     */
    'role'?: UserRole;
    /**
     * 
     * @type {string}
     * @memberof GetMeResult
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface GetMeV1200Response
 */
export interface GetMeV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetMeV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetMeResult}
     * @memberof GetMeV1200Response
     */
    'result'?: GetMeResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetMeV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetTopicInfoResult
 */
export interface GetTopicInfoResult {
    /**
     * 
     * @type {number}
     * @memberof GetTopicInfoResult
     */
    'topic_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTopicInfoResult
     */
    'topic_name'?: string;
}
/**
 * 
 * @export
 * @interface GetTopicInfoV1200Response
 */
export interface GetTopicInfoV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetTopicInfoV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetTopicInfoResult}
     * @memberof GetTopicInfoV1200Response
     */
    'result'?: GetTopicInfoResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetTopicInfoV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserCoursesData
 */
export interface GetUserCoursesData {
    /**
     * 
     * @type {string}
     * @memberof GetUserCoursesData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface GetUserCoursesResult
 */
export interface GetUserCoursesResult {
    /**
     * 
     * @type {Array<UserParticipatedCourse>}
     * @memberof GetUserCoursesResult
     */
    'courses'?: Array<UserParticipatedCourse>;
}
/**
 * 
 * @export
 * @interface GetUserCoursesV1200Response
 */
export interface GetUserCoursesV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetUserCoursesV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetUserCoursesResult}
     * @memberof GetUserCoursesV1200Response
     */
    'result'?: GetUserCoursesResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserCoursesV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserExamsHistoryV1200Response
 */
export interface GetUserExamsHistoryV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetUserExamsHistoryV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetUsersExamHistoryResult}
     * @memberof GetUserExamsHistoryV1200Response
     */
    'result'?: GetUsersExamHistoryResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserExamsHistoryV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserInfoResult
 */
export interface GetUserInfoResult {
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResult
     */
    'ban_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResult
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResult
     */
    'full_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserInfoResult
     */
    'is_banned'?: boolean;
    /**
     * 
     * @type {UserRole}
     * @memberof GetUserInfoResult
     */
    'role'?: UserRole;
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResult
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface GetUserInfoV1200Response
 */
export interface GetUserInfoV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetUserInfoV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetUserInfoResult}
     * @memberof GetUserInfoV1200Response
     */
    'result'?: GetUserInfoResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserInfoV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserOngoingExamsResult
 */
export interface GetUserOngoingExamsResult {
    /**
     * 
     * @type {Array<UserOngoingExamInfo>}
     * @memberof GetUserOngoingExamsResult
     */
    'exams'?: Array<UserOngoingExamInfo>;
}
/**
 * 
 * @export
 * @interface GetUserOngoingExamsV1200Response
 */
export interface GetUserOngoingExamsV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetUserOngoingExamsV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetUserOngoingExamsResult}
     * @memberof GetUserOngoingExamsV1200Response
     */
    'result'?: GetUserOngoingExamsResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserOngoingExamsV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserTopicStatData
 */
export interface GetUserTopicStatData {
    /**
     * 
     * @type {number}
     * @memberof GetUserTopicStatData
     */
    'topic_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetUserTopicStatData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface GetUserTopicStatResult
 */
export interface GetUserTopicStatResult {
    /**
     * 
     * @type {UserTopicStatInfo}
     * @memberof GetUserTopicStatResult
     */
    'stat'?: UserTopicStatInfo;
}
/**
 * 
 * @export
 * @interface GetUserTopicStatV1200Response
 */
export interface GetUserTopicStatV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof GetUserTopicStatV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {GetUserTopicStatResult}
     * @memberof GetUserTopicStatV1200Response
     */
    'result'?: GetUserTopicStatResult;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserTopicStatV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUsersExamHistoryData
 */
export interface GetUsersExamHistoryData {
    /**
     * 
     * @type {number}
     * @memberof GetUsersExamHistoryData
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetUsersExamHistoryData
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetUsersExamHistoryData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface GetUsersExamHistoryResult
 */
export interface GetUsersExamHistoryResult {
    /**
     * 
     * @type {Array<UserExamHistoryInfo>}
     * @memberof GetUsersExamHistoryResult
     */
    'exams'?: Array<UserExamHistoryInfo>;
}
/**
 * 
 * @export
 * @interface LoginData
 */
export interface LoginData {
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'captcha_answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'captcha_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'client_rid'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginResult
     */
    'expiration'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {UserRole}
     * @memberof LoginResult
     */
    'role'?: UserRole;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface LoginV1200Response
 */
export interface LoginV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof LoginV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {LoginResult}
     * @memberof LoginV1200Response
     */
    'result'?: LoginResult;
    /**
     * 
     * @type {boolean}
     * @memberof LoginV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ParticipateExamData
 */
export interface ParticipateExamData {
    /**
     * ExamId is the exam the user is trying to participate in.
     * @type {number}
     * @memberof ParticipateExamData
     */
    'exam_id'?: number;
    /**
     * Price is the price of the exam that user has already paid.
     * @type {string}
     * @memberof ParticipateExamData
     */
    'price'?: string;
    /**
     * UserId is the user who is trying to participate in the exam. If the user is trying to participate in the exam themselves, this field should be set to their own user id.
     * @type {string}
     * @memberof ParticipateExamData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface ParticipateExamResult
 */
export interface ParticipateExamResult {
    /**
     * 
     * @type {string}
     * @memberof ParticipateExamResult
     */
    'added_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipateExamResult
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParticipateExamResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParticipateExamResult
     */
    'finishes_in'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParticipateExamResult
     */
    'price'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParticipateExamResult
     */
    'question_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParticipateExamResult
     */
    'starts_in'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParticipateExamResult
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface ParticipateExamV1200Response
 */
export interface ParticipateExamV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof ParticipateExamV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {ParticipateExamResult}
     * @memberof ParticipateExamV1200Response
     */
    'result'?: ParticipateExamResult;
    /**
     * 
     * @type {boolean}
     * @memberof ParticipateExamV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ReAuthV1200Response
 */
export interface ReAuthV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof ReAuthV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {AuthResult}
     * @memberof ReAuthV1200Response
     */
    'result'?: AuthResult;
    /**
     * 
     * @type {boolean}
     * @memberof ReAuthV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchCourseData
 */
export interface SearchCourseData {
    /**
     * 
     * @type {string}
     * @memberof SearchCourseData
     */
    'course_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchCourseData
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchCourseData
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface SearchCourseResult
 */
export interface SearchCourseResult {
    /**
     * 
     * @type {Array<SearchedCourseInfo>}
     * @memberof SearchCourseResult
     */
    'courses'?: Array<SearchedCourseInfo>;
}
/**
 * 
 * @export
 * @interface SearchCourseV1200Response
 */
export interface SearchCourseV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof SearchCourseV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {SearchCourseResult}
     * @memberof SearchCourseV1200Response
     */
    'result'?: SearchCourseResult;
    /**
     * 
     * @type {boolean}
     * @memberof SearchCourseV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchExamData
 */
export interface SearchExamData {
    /**
     * 
     * @type {number}
     * @memberof SearchExamData
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof SearchExamData
     */
    'offset': number;
    /**
     * 
     * @type {string}
     * @memberof SearchExamData
     */
    'search_query': string;
}
/**
 * 
 * @export
 * @interface SearchExamResult
 */
export interface SearchExamResult {
    /**
     * 
     * @type {Array<SearchedExamInfo>}
     * @memberof SearchExamResult
     */
    'exams'?: Array<SearchedExamInfo>;
}
/**
 * 
 * @export
 * @interface SearchExamV1200Response
 */
export interface SearchExamV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof SearchExamV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {SearchExamResult}
     * @memberof SearchExamV1200Response
     */
    'result'?: SearchExamResult;
    /**
     * 
     * @type {boolean}
     * @memberof SearchExamV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchTopicData
 */
export interface SearchTopicData {
    /**
     * 
     * @type {string}
     * @memberof SearchTopicData
     */
    'topic_name'?: string;
}
/**
 * 
 * @export
 * @interface SearchTopicResult
 */
export interface SearchTopicResult {
    /**
     * 
     * @type {Array<SearchedTopicInfo>}
     * @memberof SearchTopicResult
     */
    'topics'?: Array<SearchedTopicInfo>;
}
/**
 * 
 * @export
 * @interface SearchTopicV1200Response
 */
export interface SearchTopicV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof SearchTopicV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {SearchTopicResult}
     * @memberof SearchTopicV1200Response
     */
    'result'?: SearchTopicResult;
    /**
     * 
     * @type {boolean}
     * @memberof SearchTopicV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchUserData
 */
export interface SearchUserData {
    /**
     * 
     * @type {number}
     * @memberof SearchUserData
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchUserData
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchUserData
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface SearchUserResult
 */
export interface SearchUserResult {
    /**
     * 
     * @type {Array<SearchedUserInfo>}
     * @memberof SearchUserResult
     */
    'users'?: Array<SearchedUserInfo>;
}
/**
 * 
 * @export
 * @interface SearchUserV1200Response
 */
export interface SearchUserV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof SearchUserV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {SearchUserResult}
     * @memberof SearchUserV1200Response
     */
    'result'?: SearchUserResult;
    /**
     * 
     * @type {boolean}
     * @memberof SearchUserV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchedCourseInfo
 */
export interface SearchedCourseInfo {
    /**
     * 
     * @type {string}
     * @memberof SearchedCourseInfo
     */
    'added_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedCourseInfo
     */
    'course_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchedCourseInfo
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchedCourseInfo
     */
    'course_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedCourseInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchedCourseInfo
     */
    'topic_id'?: number;
}
/**
 * 
 * @export
 * @interface SearchedExamInfo
 */
export interface SearchedExamInfo {
    /**
     * 
     * @type {number}
     * @memberof SearchedExamInfo
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchedExamInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedExamInfo
     */
    'created_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchedExamInfo
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchedExamInfo
     */
    'exam_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedExamInfo
     */
    'exam_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchedExamInfo
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchedExamInfo
     */
    'exam_title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchedExamInfo
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SearchedExamInfo
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface SearchedTopicInfo
 */
export interface SearchedTopicInfo {
    /**
     * 
     * @type {number}
     * @memberof SearchedTopicInfo
     */
    'topic_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchedTopicInfo
     */
    'topic_name'?: string;
}
/**
 * 
 * @export
 * @interface SearchedUserInfo
 */
export interface SearchedUserInfo {
    /**
     * 
     * @type {string}
     * @memberof SearchedUserInfo
     */
    'ban_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedUserInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedUserInfo
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedUserInfo
     */
    'full_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchedUserInfo
     */
    'is_banned'?: boolean;
    /**
     * 
     * @type {UserRole}
     * @memberof SearchedUserInfo
     */
    'role'?: UserRole;
    /**
     * 
     * @type {string}
     * @memberof SearchedUserInfo
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @interface SetScoreData
 */
export interface SetScoreData {
    /**
     * ExamId is the exam we are trying to give this score to.
     * @type {number}
     * @memberof SetScoreData
     */
    'exam_id'?: number;
    /**
     * Score is the score we are trying to give to the user.
     * @type {string}
     * @memberof SetScoreData
     */
    'score'?: string;
    /**
     * UserId is the person we are trying to give this score to.
     * @type {string}
     * @memberof SetScoreData
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface SetScoreResult
 */
export interface SetScoreResult {
    /**
     * 
     * @type {number}
     * @memberof SetScoreResult
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SetScoreResult
     */
    'score'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetScoreResult
     */
    'scored_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetScoreResult
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface SetScoreV1200Response
 */
export interface SetScoreV1200Response {
    /**
     * 
     * @type {EndpointError}
     * @memberof SetScoreV1200Response
     */
    'error'?: EndpointError;
    /**
     * 
     * @type {SetScoreResult}
     * @memberof SetScoreV1200Response
     */
    'result'?: SetScoreResult;
    /**
     * 
     * @type {boolean}
     * @memberof SetScoreV1200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface UserExamHistoryInfo
 */
export interface UserExamHistoryInfo {
    /**
     * 
     * @type {number}
     * @memberof UserExamHistoryInfo
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserExamHistoryInfo
     */
    'exam_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserExamHistoryInfo
     */
    'started_at'?: string;
}
/**
 * 
 * @export
 * @interface UserOngoingExamInfo
 */
export interface UserOngoingExamInfo {
    /**
     * 
     * @type {number}
     * @memberof UserOngoingExamInfo
     */
    'course_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserOngoingExamInfo
     */
    'exam_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOngoingExamInfo
     */
    'start_time'?: string;
}
/**
 * 
 * @export
 * @interface UserParticipatedCourse
 */
export interface UserParticipatedCourse {
    /**
     * 
     * @type {number}
     * @memberof UserParticipatedCourse
     */
    'course_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserParticipatedCourse
     */
    'course_name'?: string;
}
/**
 * UserRole is the role of the user.
 * @export
 * @enum {string}
 */

export const UserRole = {
    UserRoleOwner: 'owner',
    UserRoleAdmin: 'admin',
    UserRoleStudent: 'student',
    UserRoleTeacher: 'teacher',
    UserRoleUnknown: ''
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];


/**
 * 
 * @export
 * @interface UserTopicStatInfo
 */
export interface UserTopicStatInfo {
    /**
     * 
     * @type {number}
     * @memberof UserTopicStatInfo
     */
    'current_exp'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserTopicStatInfo
     */
    'current_level'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserTopicStatInfo
     */
    'last_visited'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserTopicStatInfo
     */
    'topic_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserTopicStatInfo
     */
    'total_exp'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserTopicStatInfo
     */
    'user_id'?: string;
}

/**
 * CourseApi - axios parameter creator
 * @export
 */
export const CourseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows a user to create a new course.
         * @summary Create a new course
         * @param {string} authorization Authorization token
         * @param {CreateCourseData} data Data needed to create a new course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1: async (authorization: string, data: CreateCourseData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createCourseV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createCourseV1', 'data', data)
            const localVarPath = `/api/v1/course/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to edit a course.
         * @summary Edit a course
         * @param {string} authorization Authorization token
         * @param {EditCourseData} data Data needed to edit a course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCourseV1: async (authorization: string, data: EditCourseData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('editCourseV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('editCourseV1', 'data', data)
            const localVarPath = `/api/v1/course/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to get information about a course by its id.
         * @summary Get course information
         * @param {string} authorization Authorization token
         * @param {number} id Course ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseInfoV1: async (authorization: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getCourseInfoV1', 'authorization', authorization)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseInfoV1', 'id', id)
            const localVarPath = `/api/v1/course/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to get all participants of a course.
         * @summary Get course participants
         * @param {string} authorization Authorization token
         * @param {GetCourseParticipantsData} data Data needed to get course participants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseParticipantsV1: async (authorization: string, data: GetCourseParticipantsData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getCourseParticipantsV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getCourseParticipantsV1', 'data', data)
            const localVarPath = `/api/v1/course/courseParticipants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to get all courses created by a user.
         * @summary Get created courses
         * @param {string} authorization Authorization token
         * @param {GetCreatedCoursesData} data Data needed to get created courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreatedCoursesV1: async (authorization: string, data: GetCreatedCoursesData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getCreatedCoursesV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getCreatedCoursesV1', 'data', data)
            const localVarPath = `/api/v1/course/createdCourses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to get all courses participated by a user.
         * @summary Get user courses
         * @param {string} authorization Authorization token
         * @param {GetUserCoursesData} data Data needed to get user courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCoursesV1: async (authorization: string, data: GetUserCoursesData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserCoursesV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getUserCoursesV1', 'data', data)
            const localVarPath = `/api/v1/course/userCourses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to search for courses by their name. Pass empty string to get all courses.
         * @summary Search for courses
         * @param {string} authorization Authorization token
         * @param {SearchCourseData} data Data needed to search for courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCourseV1: async (authorization: string, data: SearchCourseData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('searchCourseV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('searchCourseV1', 'data', data)
            const localVarPath = `/api/v1/course/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseApi - functional programming interface
 * @export
 */
export const CourseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows a user to create a new course.
         * @summary Create a new course
         * @param {string} authorization Authorization token
         * @param {CreateCourseData} data Data needed to create a new course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseV1(authorization: string, data: CreateCourseData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCourseV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.createCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to edit a course.
         * @summary Edit a course
         * @param {string} authorization Authorization token
         * @param {EditCourseData} data Data needed to edit a course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCourseV1(authorization: string, data: EditCourseData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditCourseV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCourseV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.editCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to get information about a course by its id.
         * @summary Get course information
         * @param {string} authorization Authorization token
         * @param {number} id Course ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseInfoV1(authorization: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCourseInfoV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseInfoV1(authorization, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getCourseInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to get all participants of a course.
         * @summary Get course participants
         * @param {string} authorization Authorization token
         * @param {GetCourseParticipantsData} data Data needed to get course participants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseParticipantsV1(authorization: string, data: GetCourseParticipantsData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCourseParticipantsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseParticipantsV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getCourseParticipantsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to get all courses created by a user.
         * @summary Get created courses
         * @param {string} authorization Authorization token
         * @param {GetCreatedCoursesData} data Data needed to get created courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreatedCoursesV1(authorization: string, data: GetCreatedCoursesData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCreatedCoursesV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreatedCoursesV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getCreatedCoursesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to get all courses participated by a user.
         * @summary Get user courses
         * @param {string} authorization Authorization token
         * @param {GetUserCoursesData} data Data needed to get user courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCoursesV1(authorization: string, data: GetUserCoursesData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserCoursesV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCoursesV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getUserCoursesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to search for courses by their name. Pass empty string to get all courses.
         * @summary Search for courses
         * @param {string} authorization Authorization token
         * @param {SearchCourseData} data Data needed to search for courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCourseV1(authorization: string, data: SearchCourseData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCourseV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCourseV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.searchCourseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseApi - factory interface
 * @export
 */
export const CourseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseApiFp(configuration)
    return {
        /**
         * Allows a user to create a new course.
         * @summary Create a new course
         * @param {string} authorization Authorization token
         * @param {CreateCourseData} data Data needed to create a new course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseV1(authorization: string, data: CreateCourseData, options?: any): AxiosPromise<CreateCourseV1200Response> {
            return localVarFp.createCourseV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to edit a course.
         * @summary Edit a course
         * @param {string} authorization Authorization token
         * @param {EditCourseData} data Data needed to edit a course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCourseV1(authorization: string, data: EditCourseData, options?: any): AxiosPromise<EditCourseV1200Response> {
            return localVarFp.editCourseV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to get information about a course by its id.
         * @summary Get course information
         * @param {string} authorization Authorization token
         * @param {number} id Course ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseInfoV1(authorization: string, id: number, options?: any): AxiosPromise<GetCourseInfoV1200Response> {
            return localVarFp.getCourseInfoV1(authorization, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to get all participants of a course.
         * @summary Get course participants
         * @param {string} authorization Authorization token
         * @param {GetCourseParticipantsData} data Data needed to get course participants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseParticipantsV1(authorization: string, data: GetCourseParticipantsData, options?: any): AxiosPromise<GetCourseParticipantsV1200Response> {
            return localVarFp.getCourseParticipantsV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to get all courses created by a user.
         * @summary Get created courses
         * @param {string} authorization Authorization token
         * @param {GetCreatedCoursesData} data Data needed to get created courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreatedCoursesV1(authorization: string, data: GetCreatedCoursesData, options?: any): AxiosPromise<GetCreatedCoursesV1200Response> {
            return localVarFp.getCreatedCoursesV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to get all courses participated by a user.
         * @summary Get user courses
         * @param {string} authorization Authorization token
         * @param {GetUserCoursesData} data Data needed to get user courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCoursesV1(authorization: string, data: GetUserCoursesData, options?: any): AxiosPromise<GetUserCoursesV1200Response> {
            return localVarFp.getUserCoursesV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to search for courses by their name. Pass empty string to get all courses.
         * @summary Search for courses
         * @param {string} authorization Authorization token
         * @param {SearchCourseData} data Data needed to search for courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCourseV1(authorization: string, data: SearchCourseData, options?: any): AxiosPromise<SearchCourseV1200Response> {
            return localVarFp.searchCourseV1(authorization, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseApi - object-oriented interface
 * @export
 * @class CourseApi
 * @extends {BaseAPI}
 */
export class CourseApi extends BaseAPI {
    /**
     * Allows a user to create a new course.
     * @summary Create a new course
     * @param {string} authorization Authorization token
     * @param {CreateCourseData} data Data needed to create a new course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public createCourseV1(authorization: string, data: CreateCourseData, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).createCourseV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to edit a course.
     * @summary Edit a course
     * @param {string} authorization Authorization token
     * @param {EditCourseData} data Data needed to edit a course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public editCourseV1(authorization: string, data: EditCourseData, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).editCourseV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to get information about a course by its id.
     * @summary Get course information
     * @param {string} authorization Authorization token
     * @param {number} id Course ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public getCourseInfoV1(authorization: string, id: number, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getCourseInfoV1(authorization, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to get all participants of a course.
     * @summary Get course participants
     * @param {string} authorization Authorization token
     * @param {GetCourseParticipantsData} data Data needed to get course participants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public getCourseParticipantsV1(authorization: string, data: GetCourseParticipantsData, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getCourseParticipantsV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to get all courses created by a user.
     * @summary Get created courses
     * @param {string} authorization Authorization token
     * @param {GetCreatedCoursesData} data Data needed to get created courses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public getCreatedCoursesV1(authorization: string, data: GetCreatedCoursesData, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getCreatedCoursesV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to get all courses participated by a user.
     * @summary Get user courses
     * @param {string} authorization Authorization token
     * @param {GetUserCoursesData} data Data needed to get user courses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public getUserCoursesV1(authorization: string, data: GetUserCoursesData, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getUserCoursesV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to search for courses by their name. Pass empty string to get all courses.
     * @summary Search for courses
     * @param {string} authorization Authorization token
     * @param {SearchCourseData} data Data needed to search for courses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseApi
     */
    public searchCourseV1(authorization: string, data: SearchCourseData, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).searchCourseV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExamApi - axios parameter creator
 * @export
 */
export const ExamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows the user to answer a question of an exam.
         * @summary Answer a question of an exam
         * @param {string} authorization Authorization token
         * @param {AnswerQuestionData} data Data needed to answer a question of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerExamQuestionV1: async (authorization: string, data: AnswerQuestionData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('answerExamQuestionV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('answerExamQuestionV1', 'data', data)
            const localVarPath = `/api/v1/exam/answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to create a new question for an exam.
         * @summary Create a new question for an exam
         * @param {string} authorization Authorization token
         * @param {CreateExamQuestionData} data Data needed to create a new question for an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamQuestionV1: async (authorization: string, data: CreateExamQuestionData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createExamQuestionV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createExamQuestionV1', 'data', data)
            const localVarPath = `/api/v1/exam/createQuestion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to create a new exam.
         * @summary Create a new exam
         * @param {string} authorization Authorization token
         * @param {CreateExamData} data Data needed to create a new exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamV1: async (authorization: string, data: CreateExamData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createExamV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createExamV1', 'data', data)
            const localVarPath = `/api/v1/exam/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to edit a question of an exam.
         * @summary Edit a question of an exam
         * @param {string} authorization Authorization token
         * @param {EditExamQuestionData} data Data needed to edit a question of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editExamQuestionV1: async (authorization: string, data: EditExamQuestionData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('editExamQuestionV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('editExamQuestionV1', 'data', data)
            const localVarPath = `/api/v1/exam/editQuestion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to edit an exam.
         * @summary Edit an exam
         * @param {string} authorization Authorization token
         * @param {EditExamData} data Data needed to edit an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editExamV1: async (authorization: string, data: EditExamData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('editExamV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('editExamV1', 'data', data)
            const localVarPath = `/api/v1/exam/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to get information about an exam.
         * @summary Get information about an exam
         * @param {string} authorization Authorization token
         * @param {number} id Exam ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamInfoV1: async (authorization: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getExamInfoV1', 'authorization', authorization)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExamInfoV1', 'id', id)
            const localVarPath = `/api/v1/exam/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to get questions of an exam.
         * @summary Get questions of an exam
         * @param {string} authorization Authorization token
         * @param {GetExamQuestionsData} data Data needed to get questions of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamQuestionsV1: async (authorization: string, data: GetExamQuestionsData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getExamQuestionsV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getExamQuestionsV1', 'data', data)
            const localVarPath = `/api/v1/exam/questions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to get information about an exam that a user has participated in.
         * @summary Get information about an exam that a user has participated in
         * @param {string} authorization Authorization token
         * @param {GetGivenExamData} data Data needed to get information about an exam that a user has participated in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGivenExamV1: async (authorization: string, data: GetGivenExamData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getGivenExamV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getGivenExamV1', 'data', data)
            const localVarPath = `/api/v1/exam/givenExam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to get history of exams of a user.
         * @summary Get history of exams of a user
         * @param {string} authorization Authorization token
         * @param {GetUsersExamHistoryData} data Data needed to get history of exams of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserExamsHistoryV1: async (authorization: string, data: GetUsersExamHistoryData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserExamsHistoryV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getUserExamsHistoryV1', 'data', data)
            const localVarPath = `/api/v1/exam/userExamsHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to get ongoing exams of a user.
         * @summary Get ongoing exams of a user
         * @param {string} authorization Authorization token
         * @param {string} [targetId] Target user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOngoingExamsV1: async (authorization: string, targetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserOngoingExamsV1', 'authorization', authorization)
            const localVarPath = `/api/v1/exam/userOngoingExams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to participate in an exam.
         * @summary Participate in an exam
         * @param {string} authorization Authorization token
         * @param {ParticipateExamData} data Data needed to participate in an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participateExamV1: async (authorization: string, data: ParticipateExamData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('participateExamV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('participateExamV1', 'data', data)
            const localVarPath = `/api/v1/exam/participate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to search exams.
         * @summary Search exams
         * @param {string} authorization Authorization token
         * @param {SearchExamData} data Data needed to search exams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExamV1: async (authorization: string, data: SearchExamData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('searchExamV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('searchExamV1', 'data', data)
            const localVarPath = `/api/v1/exam/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the user to set score for a user in an exam.
         * @summary Set score for a user in an exam
         * @param {string} authorization Authorization token
         * @param {SetScoreData} data Data needed to set score for a user in an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScoreV1: async (authorization: string, data: SetScoreData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('setScoreV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('setScoreV1', 'data', data)
            const localVarPath = `/api/v1/exam/setScore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamApi - functional programming interface
 * @export
 */
export const ExamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows the user to answer a question of an exam.
         * @summary Answer a question of an exam
         * @param {string} authorization Authorization token
         * @param {AnswerQuestionData} data Data needed to answer a question of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerExamQuestionV1(authorization: string, data: AnswerQuestionData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnswerExamQuestionV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerExamQuestionV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.answerExamQuestionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to create a new question for an exam.
         * @summary Create a new question for an exam
         * @param {string} authorization Authorization token
         * @param {CreateExamQuestionData} data Data needed to create a new question for an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamQuestionV1(authorization: string, data: CreateExamQuestionData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExamQuestionV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamQuestionV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.createExamQuestionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to create a new exam.
         * @summary Create a new exam
         * @param {string} authorization Authorization token
         * @param {CreateExamData} data Data needed to create a new exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExamV1(authorization: string, data: CreateExamData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExamV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExamV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.createExamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to edit a question of an exam.
         * @summary Edit a question of an exam
         * @param {string} authorization Authorization token
         * @param {EditExamQuestionData} data Data needed to edit a question of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editExamQuestionV1(authorization: string, data: EditExamQuestionData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditExamQuestionV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editExamQuestionV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.editExamQuestionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to edit an exam.
         * @summary Edit an exam
         * @param {string} authorization Authorization token
         * @param {EditExamData} data Data needed to edit an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editExamV1(authorization: string, data: EditExamData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditExamV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editExamV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.editExamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to get information about an exam.
         * @summary Get information about an exam
         * @param {string} authorization Authorization token
         * @param {number} id Exam ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExamInfoV1(authorization: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExamInfoV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExamInfoV1(authorization, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.getExamInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to get questions of an exam.
         * @summary Get questions of an exam
         * @param {string} authorization Authorization token
         * @param {GetExamQuestionsData} data Data needed to get questions of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExamQuestionsV1(authorization: string, data: GetExamQuestionsData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExamQuestionsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExamQuestionsV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.getExamQuestionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to get information about an exam that a user has participated in.
         * @summary Get information about an exam that a user has participated in
         * @param {string} authorization Authorization token
         * @param {GetGivenExamData} data Data needed to get information about an exam that a user has participated in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGivenExamV1(authorization: string, data: GetGivenExamData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGivenExamV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGivenExamV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.getGivenExamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to get history of exams of a user.
         * @summary Get history of exams of a user
         * @param {string} authorization Authorization token
         * @param {GetUsersExamHistoryData} data Data needed to get history of exams of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserExamsHistoryV1(authorization: string, data: GetUsersExamHistoryData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserExamsHistoryV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserExamsHistoryV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.getUserExamsHistoryV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to get ongoing exams of a user.
         * @summary Get ongoing exams of a user
         * @param {string} authorization Authorization token
         * @param {string} [targetId] Target user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserOngoingExamsV1(authorization: string, targetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserOngoingExamsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserOngoingExamsV1(authorization, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.getUserOngoingExamsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to participate in an exam.
         * @summary Participate in an exam
         * @param {string} authorization Authorization token
         * @param {ParticipateExamData} data Data needed to participate in an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participateExamV1(authorization: string, data: ParticipateExamData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParticipateExamV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participateExamV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.participateExamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to search exams.
         * @summary Search exams
         * @param {string} authorization Authorization token
         * @param {SearchExamData} data Data needed to search exams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchExamV1(authorization: string, data: SearchExamData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchExamV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchExamV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.searchExamV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the user to set score for a user in an exam.
         * @summary Set score for a user in an exam
         * @param {string} authorization Authorization token
         * @param {SetScoreData} data Data needed to set score for a user in an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setScoreV1(authorization: string, data: SetScoreData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetScoreV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setScoreV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExamApi.setScoreV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExamApi - factory interface
 * @export
 */
export const ExamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamApiFp(configuration)
    return {
        /**
         * Allows the user to answer a question of an exam.
         * @summary Answer a question of an exam
         * @param {string} authorization Authorization token
         * @param {AnswerQuestionData} data Data needed to answer a question of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerExamQuestionV1(authorization: string, data: AnswerQuestionData, options?: any): AxiosPromise<AnswerExamQuestionV1200Response> {
            return localVarFp.answerExamQuestionV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to create a new question for an exam.
         * @summary Create a new question for an exam
         * @param {string} authorization Authorization token
         * @param {CreateExamQuestionData} data Data needed to create a new question for an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamQuestionV1(authorization: string, data: CreateExamQuestionData, options?: any): AxiosPromise<CreateExamQuestionV1200Response> {
            return localVarFp.createExamQuestionV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to create a new exam.
         * @summary Create a new exam
         * @param {string} authorization Authorization token
         * @param {CreateExamData} data Data needed to create a new exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExamV1(authorization: string, data: CreateExamData, options?: any): AxiosPromise<CreateExamV1200Response> {
            return localVarFp.createExamV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to edit a question of an exam.
         * @summary Edit a question of an exam
         * @param {string} authorization Authorization token
         * @param {EditExamQuestionData} data Data needed to edit a question of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editExamQuestionV1(authorization: string, data: EditExamQuestionData, options?: any): AxiosPromise<EditExamQuestionV1200Response> {
            return localVarFp.editExamQuestionV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to edit an exam.
         * @summary Edit an exam
         * @param {string} authorization Authorization token
         * @param {EditExamData} data Data needed to edit an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editExamV1(authorization: string, data: EditExamData, options?: any): AxiosPromise<EditExamV1200Response> {
            return localVarFp.editExamV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to get information about an exam.
         * @summary Get information about an exam
         * @param {string} authorization Authorization token
         * @param {number} id Exam ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamInfoV1(authorization: string, id: number, options?: any): AxiosPromise<GetExamInfoV1200Response> {
            return localVarFp.getExamInfoV1(authorization, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to get questions of an exam.
         * @summary Get questions of an exam
         * @param {string} authorization Authorization token
         * @param {GetExamQuestionsData} data Data needed to get questions of an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExamQuestionsV1(authorization: string, data: GetExamQuestionsData, options?: any): AxiosPromise<GetExamQuestionsV1200Response> {
            return localVarFp.getExamQuestionsV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to get information about an exam that a user has participated in.
         * @summary Get information about an exam that a user has participated in
         * @param {string} authorization Authorization token
         * @param {GetGivenExamData} data Data needed to get information about an exam that a user has participated in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGivenExamV1(authorization: string, data: GetGivenExamData, options?: any): AxiosPromise<GetGivenExamV1200Response> {
            return localVarFp.getGivenExamV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to get history of exams of a user.
         * @summary Get history of exams of a user
         * @param {string} authorization Authorization token
         * @param {GetUsersExamHistoryData} data Data needed to get history of exams of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserExamsHistoryV1(authorization: string, data: GetUsersExamHistoryData, options?: any): AxiosPromise<GetUserExamsHistoryV1200Response> {
            return localVarFp.getUserExamsHistoryV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to get ongoing exams of a user.
         * @summary Get ongoing exams of a user
         * @param {string} authorization Authorization token
         * @param {string} [targetId] Target user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOngoingExamsV1(authorization: string, targetId?: string, options?: any): AxiosPromise<GetUserOngoingExamsV1200Response> {
            return localVarFp.getUserOngoingExamsV1(authorization, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to participate in an exam.
         * @summary Participate in an exam
         * @param {string} authorization Authorization token
         * @param {ParticipateExamData} data Data needed to participate in an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participateExamV1(authorization: string, data: ParticipateExamData, options?: any): AxiosPromise<ParticipateExamV1200Response> {
            return localVarFp.participateExamV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to search exams.
         * @summary Search exams
         * @param {string} authorization Authorization token
         * @param {SearchExamData} data Data needed to search exams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExamV1(authorization: string, data: SearchExamData, options?: any): AxiosPromise<SearchExamV1200Response> {
            return localVarFp.searchExamV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the user to set score for a user in an exam.
         * @summary Set score for a user in an exam
         * @param {string} authorization Authorization token
         * @param {SetScoreData} data Data needed to set score for a user in an exam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScoreV1(authorization: string, data: SetScoreData, options?: any): AxiosPromise<SetScoreV1200Response> {
            return localVarFp.setScoreV1(authorization, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamApi - object-oriented interface
 * @export
 * @class ExamApi
 * @extends {BaseAPI}
 */
export class ExamApi extends BaseAPI {
    /**
     * Allows the user to answer a question of an exam.
     * @summary Answer a question of an exam
     * @param {string} authorization Authorization token
     * @param {AnswerQuestionData} data Data needed to answer a question of an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public answerExamQuestionV1(authorization: string, data: AnswerQuestionData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).answerExamQuestionV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to create a new question for an exam.
     * @summary Create a new question for an exam
     * @param {string} authorization Authorization token
     * @param {CreateExamQuestionData} data Data needed to create a new question for an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public createExamQuestionV1(authorization: string, data: CreateExamQuestionData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).createExamQuestionV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to create a new exam.
     * @summary Create a new exam
     * @param {string} authorization Authorization token
     * @param {CreateExamData} data Data needed to create a new exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public createExamV1(authorization: string, data: CreateExamData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).createExamV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to edit a question of an exam.
     * @summary Edit a question of an exam
     * @param {string} authorization Authorization token
     * @param {EditExamQuestionData} data Data needed to edit a question of an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public editExamQuestionV1(authorization: string, data: EditExamQuestionData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).editExamQuestionV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to edit an exam.
     * @summary Edit an exam
     * @param {string} authorization Authorization token
     * @param {EditExamData} data Data needed to edit an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public editExamV1(authorization: string, data: EditExamData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).editExamV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to get information about an exam.
     * @summary Get information about an exam
     * @param {string} authorization Authorization token
     * @param {number} id Exam ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public getExamInfoV1(authorization: string, id: number, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).getExamInfoV1(authorization, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to get questions of an exam.
     * @summary Get questions of an exam
     * @param {string} authorization Authorization token
     * @param {GetExamQuestionsData} data Data needed to get questions of an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public getExamQuestionsV1(authorization: string, data: GetExamQuestionsData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).getExamQuestionsV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to get information about an exam that a user has participated in.
     * @summary Get information about an exam that a user has participated in
     * @param {string} authorization Authorization token
     * @param {GetGivenExamData} data Data needed to get information about an exam that a user has participated in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public getGivenExamV1(authorization: string, data: GetGivenExamData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).getGivenExamV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to get history of exams of a user.
     * @summary Get history of exams of a user
     * @param {string} authorization Authorization token
     * @param {GetUsersExamHistoryData} data Data needed to get history of exams of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public getUserExamsHistoryV1(authorization: string, data: GetUsersExamHistoryData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).getUserExamsHistoryV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to get ongoing exams of a user.
     * @summary Get ongoing exams of a user
     * @param {string} authorization Authorization token
     * @param {string} [targetId] Target user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public getUserOngoingExamsV1(authorization: string, targetId?: string, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).getUserOngoingExamsV1(authorization, targetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to participate in an exam.
     * @summary Participate in an exam
     * @param {string} authorization Authorization token
     * @param {ParticipateExamData} data Data needed to participate in an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public participateExamV1(authorization: string, data: ParticipateExamData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).participateExamV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to search exams.
     * @summary Search exams
     * @param {string} authorization Authorization token
     * @param {SearchExamData} data Data needed to search exams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public searchExamV1(authorization: string, data: SearchExamData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).searchExamV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the user to set score for a user in an exam.
     * @summary Set score for a user in an exam
     * @param {string} authorization Authorization token
     * @param {SetScoreData} data Data needed to set score for a user in an exam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public setScoreV1(authorization: string, data: SetScoreData, options?: RawAxiosRequestConfig) {
        return ExamApiFp(this.configuration).setScoreV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new topic
         * @summary Create a new topic
         * @param {string} authorization Authorization token
         * @param {CreateNewTopicData} data Data needed to create a new topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopicV1: async (authorization: string, data: CreateNewTopicData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createTopicV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createTopicV1', 'data', data)
            const localVarPath = `/api/v1/topic/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows moderators to delete a topic. All courses and exams related to the topic will be deleted as well.
         * @summary Delete a topic
         * @param {string} authorization Authorization token
         * @param {number} id Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopicV1: async (authorization: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteTopicV1', 'authorization', authorization)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTopicV1', 'id', id)
            const localVarPath = `/api/v1/topic/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all user topic stats
         * @summary Get all user topic stats
         * @param {string} authorization Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserTopicStatsV1: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAllUserTopicStatsV1', 'authorization', authorization)
            const localVarPath = `/api/v1/topic/allUserTopicStats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get topic info
         * @summary Get topic info
         * @param {string} authorization Authorization token
         * @param {number} id Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInfoV1: async (authorization: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getTopicInfoV1', 'authorization', authorization)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTopicInfoV1', 'id', id)
            const localVarPath = `/api/v1/topic/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user topic stat
         * @summary Get user topic stat
         * @param {string} authorization Authorization token
         * @param {GetUserTopicStatData} data Data needed to get user topic stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopicStatV1: async (authorization: string, data: GetUserTopicStatData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserTopicStatV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getUserTopicStatV1', 'data', data)
            const localVarPath = `/api/v1/topic/userTopicStat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for topics
         * @summary Search for topics
         * @param {string} authorization Authorization token
         * @param {SearchTopicData} data Data needed to search for topics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopicV1: async (authorization: string, data: SearchTopicData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('searchTopicV1', 'authorization', authorization)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('searchTopicV1', 'data', data)
            const localVarPath = `/api/v1/topic/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new topic
         * @summary Create a new topic
         * @param {string} authorization Authorization token
         * @param {CreateNewTopicData} data Data needed to create a new topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTopicV1(authorization: string, data: CreateNewTopicData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTopicV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTopicV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.createTopicV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows moderators to delete a topic. All courses and exams related to the topic will be deleted as well.
         * @summary Delete a topic
         * @param {string} authorization Authorization token
         * @param {number} id Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopicV1(authorization: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTopicV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopicV1(authorization, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.deleteTopicV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all user topic stats
         * @summary Get all user topic stats
         * @param {string} authorization Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUserTopicStatsV1(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllUserTopicStatsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUserTopicStatsV1(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.getAllUserTopicStatsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get topic info
         * @summary Get topic info
         * @param {string} authorization Authorization token
         * @param {number} id Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopicInfoV1(authorization: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTopicInfoV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopicInfoV1(authorization, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.getTopicInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user topic stat
         * @summary Get user topic stat
         * @param {string} authorization Authorization token
         * @param {GetUserTopicStatData} data Data needed to get user topic stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTopicStatV1(authorization: string, data: GetUserTopicStatData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTopicStatV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTopicStatV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.getUserTopicStatV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for topics
         * @summary Search for topics
         * @param {string} authorization Authorization token
         * @param {SearchTopicData} data Data needed to search for topics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTopicV1(authorization: string, data: SearchTopicData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchTopicV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTopicV1(authorization, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicApi.searchTopicV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicApiFp(configuration)
    return {
        /**
         * Create a new topic
         * @summary Create a new topic
         * @param {string} authorization Authorization token
         * @param {CreateNewTopicData} data Data needed to create a new topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopicV1(authorization: string, data: CreateNewTopicData, options?: any): AxiosPromise<CreateTopicV1200Response> {
            return localVarFp.createTopicV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows moderators to delete a topic. All courses and exams related to the topic will be deleted as well.
         * @summary Delete a topic
         * @param {string} authorization Authorization token
         * @param {number} id Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopicV1(authorization: string, id: number, options?: any): AxiosPromise<DeleteTopicV1200Response> {
            return localVarFp.deleteTopicV1(authorization, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all user topic stats
         * @summary Get all user topic stats
         * @param {string} authorization Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserTopicStatsV1(authorization: string, options?: any): AxiosPromise<GetAllUserTopicStatsV1200Response> {
            return localVarFp.getAllUserTopicStatsV1(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Get topic info
         * @summary Get topic info
         * @param {string} authorization Authorization token
         * @param {number} id Topic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicInfoV1(authorization: string, id: number, options?: any): AxiosPromise<GetTopicInfoV1200Response> {
            return localVarFp.getTopicInfoV1(authorization, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user topic stat
         * @summary Get user topic stat
         * @param {string} authorization Authorization token
         * @param {GetUserTopicStatData} data Data needed to get user topic stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTopicStatV1(authorization: string, data: GetUserTopicStatData, options?: any): AxiosPromise<GetUserTopicStatV1200Response> {
            return localVarFp.getUserTopicStatV1(authorization, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for topics
         * @summary Search for topics
         * @param {string} authorization Authorization token
         * @param {SearchTopicData} data Data needed to search for topics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopicV1(authorization: string, data: SearchTopicData, options?: any): AxiosPromise<SearchTopicV1200Response> {
            return localVarFp.searchTopicV1(authorization, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * Create a new topic
     * @summary Create a new topic
     * @param {string} authorization Authorization token
     * @param {CreateNewTopicData} data Data needed to create a new topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public createTopicV1(authorization: string, data: CreateNewTopicData, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).createTopicV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows moderators to delete a topic. All courses and exams related to the topic will be deleted as well.
     * @summary Delete a topic
     * @param {string} authorization Authorization token
     * @param {number} id Topic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public deleteTopicV1(authorization: string, id: number, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).deleteTopicV1(authorization, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all user topic stats
     * @summary Get all user topic stats
     * @param {string} authorization Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getAllUserTopicStatsV1(authorization: string, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).getAllUserTopicStatsV1(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get topic info
     * @summary Get topic info
     * @param {string} authorization Authorization token
     * @param {number} id Topic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getTopicInfoV1(authorization: string, id: number, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).getTopicInfoV1(authorization, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user topic stat
     * @summary Get user topic stat
     * @param {string} authorization Authorization token
     * @param {GetUserTopicStatData} data Data needed to get user topic stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public getUserTopicStatV1(authorization: string, data: GetUserTopicStatData, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).getUserTopicStatV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for topics
     * @summary Search for topics
     * @param {string} authorization Authorization token
     * @param {SearchTopicData} data Data needed to search for topics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public searchTopicV1(authorization: string, data: SearchTopicData, options?: RawAxiosRequestConfig) {
        return TopicApiFp(this.configuration).searchTopicV1(authorization, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows a user to ban another user
         * @summary Ban a user
         * @param {string} authorization Authorization token
         * @param {BanUserData} banUserData Ban user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUserV1: async (authorization: string, banUserData: BanUserData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('banUserV1', 'authorization', authorization)
            // verify required parameter 'banUserData' is not null or undefined
            assertParamExists('banUserV1', 'banUserData', banUserData)
            const localVarPath = `/api/v1/user/ban`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to change a user\'s password.
         * @summary Change a user\'s password
         * @param {string} authorization Authorization token
         * @param {ChangePasswordData} changePasswordData Change password data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordV1: async (authorization: string, changePasswordData: ChangePasswordData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('changePasswordV1', 'authorization', authorization)
            // verify required parameter 'changePasswordData' is not null or undefined
            assertParamExists('changePasswordV1', 'changePasswordData', changePasswordData)
            const localVarPath = `/api/v1/user/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to confirm their account
         * @summary Confirm account
         * @param {ConfirmAccountData} confirmAccountData Confirm account data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmAccountV1: async (confirmAccountData: ConfirmAccountData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmAccountData' is not null or undefined
            assertParamExists('confirmAccountV1', 'confirmAccountData', confirmAccountData)
            const localVarPath = `/api/v1/user/confirmAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmAccountData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to confirm changing their own\'s password (from redirected page)
         * @summary Confirm changing your own\'s password
         * @param {ConfirmChangePasswordData} confirmChangePasswordData Confirm change password data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmChangePasswordV1: async (confirmChangePasswordData: ConfirmChangePasswordData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmChangePasswordData' is not null or undefined
            assertParamExists('confirmChangePasswordV1', 'confirmChangePasswordData', confirmChangePasswordData)
            const localVarPath = `/api/v1/user/confirmChangePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmChangePasswordData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to create a new user
         * @summary Create a new user
         * @param {string} authorization Authorization token
         * @param {CreateUserData} createUserData Create user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1: async (authorization: string, createUserData: CreateUserData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createUserV1', 'authorization', authorization)
            // verify required parameter 'createUserData' is not null or undefined
            assertParamExists('createUserV1', 'createUserData', createUserData)
            const localVarPath = `/api/v1/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to edit another user. Users are not allowed to edit their own information.
         * @summary Edit a user\'s basic information
         * @param {string} authorization Authorization token
         * @param {EditUserData} editUserData Edit user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserV1: async (authorization: string, editUserData: EditUserData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('editUserV1', 'authorization', authorization)
            // verify required parameter 'editUserData' is not null or undefined
            assertParamExists('editUserV1', 'editUserData', editUserData)
            const localVarPath = `/api/v1/user/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a client (with Client-R-ID) to generate a captcha
         * @summary Get a captcha
         * @param {string} clientRID Client-R-ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCaptchaV1: async (clientRID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientRID' is not null or undefined
            assertParamExists('generateCaptchaV1', 'clientRID', clientRID)
            const localVarPath = `/api/v1/captcha/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientRID != null) {
                localVarHeaderParameter['Client-R-ID'] = String(clientRID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to get their own information
         * @summary Get the user\'s information
         * @param {string} authorization Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeV1: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMeV1', 'authorization', authorization)
            const localVarPath = `/api/v1/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to get another user\'s information by their user ID
         * @summary Get a user\'s information
         * @param {string} authorization Authorization token
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoV1: async (authorization: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserInfoV1', 'authorization', authorization)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserInfoV1', 'id', id)
            const localVarPath = `/api/v1/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to login to the system and obtain access/refresh tokens
         * @summary Login to the system
         * @param {LoginData} loginData Login data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginV1: async (loginData: LoginData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginData' is not null or undefined
            assertParamExists('loginV1', 'loginData', loginData)
            const localVarPath = `/api/v1/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to refresh their access token
         * @summary Refresh the access token
         * @param {string} authorization Refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reAuthV1: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('reAuthV1', 'authorization', authorization)
            const localVarPath = `/api/v1/user/reAuth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to search for users
         * @summary Search users
         * @param {string} authorization Authorization token
         * @param {SearchUserData} searchUserData Search user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserV1: async (authorization: string, searchUserData: SearchUserData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('searchUserV1', 'authorization', authorization)
            // verify required parameter 'searchUserData' is not null or undefined
            assertParamExists('searchUserV1', 'searchUserData', searchUserData)
            const localVarPath = `/api/v1/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchUserData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows a user to ban another user
         * @summary Ban a user
         * @param {string} authorization Authorization token
         * @param {BanUserData} banUserData Ban user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banUserV1(authorization: string, banUserData: BanUserData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanUserV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banUserV1(authorization, banUserData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.banUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to change a user\'s password.
         * @summary Change a user\'s password
         * @param {string} authorization Authorization token
         * @param {ChangePasswordData} changePasswordData Change password data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordV1(authorization: string, changePasswordData: ChangePasswordData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePasswordV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordV1(authorization, changePasswordData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.changePasswordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to confirm their account
         * @summary Confirm account
         * @param {ConfirmAccountData} confirmAccountData Confirm account data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmAccountV1(confirmAccountData: ConfirmAccountData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTopicV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmAccountV1(confirmAccountData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.confirmAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to confirm changing their own\'s password (from redirected page)
         * @summary Confirm changing your own\'s password
         * @param {ConfirmChangePasswordData} confirmChangePasswordData Confirm change password data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmChangePasswordV1(confirmChangePasswordData: ConfirmChangePasswordData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTopicV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmChangePasswordV1(confirmChangePasswordData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.confirmChangePasswordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to create a new user
         * @summary Create a new user
         * @param {string} authorization Authorization token
         * @param {CreateUserData} createUserData Create user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserV1(authorization: string, createUserData: CreateUserData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserV1(authorization, createUserData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to edit another user. Users are not allowed to edit their own information.
         * @summary Edit a user\'s basic information
         * @param {string} authorization Authorization token
         * @param {EditUserData} editUserData Edit user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUserV1(authorization: string, editUserData: EditUserData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditUserV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUserV1(authorization, editUserData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.editUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a client (with Client-R-ID) to generate a captcha
         * @summary Get a captcha
         * @param {string} clientRID Client-R-ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCaptchaV1(clientRID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateCaptchaV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCaptchaV1(clientRID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.generateCaptchaV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to get their own information
         * @summary Get the user\'s information
         * @param {string} authorization Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeV1(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMeV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeV1(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMeV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to get another user\'s information by their user ID
         * @summary Get a user\'s information
         * @param {string} authorization Authorization token
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfoV1(authorization: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserInfoV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoV1(authorization, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserInfoV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to login to the system and obtain access/refresh tokens
         * @summary Login to the system
         * @param {LoginData} loginData Login data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginV1(loginData: LoginData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginV1(loginData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.loginV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to refresh their access token
         * @summary Refresh the access token
         * @param {string} authorization Refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reAuthV1(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReAuthV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reAuthV1(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.reAuthV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to search for users
         * @summary Search users
         * @param {string} authorization Authorization token
         * @param {SearchUserData} searchUserData Search user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUserV1(authorization: string, searchUserData: SearchUserData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchUserV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUserV1(authorization, searchUserData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.searchUserV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Allows a user to ban another user
         * @summary Ban a user
         * @param {string} authorization Authorization token
         * @param {BanUserData} banUserData Ban user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUserV1(authorization: string, banUserData: BanUserData, options?: any): AxiosPromise<BanUserV1200Response> {
            return localVarFp.banUserV1(authorization, banUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to change a user\'s password.
         * @summary Change a user\'s password
         * @param {string} authorization Authorization token
         * @param {ChangePasswordData} changePasswordData Change password data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordV1(authorization: string, changePasswordData: ChangePasswordData, options?: any): AxiosPromise<ChangePasswordV1200Response> {
            return localVarFp.changePasswordV1(authorization, changePasswordData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to confirm their account
         * @summary Confirm account
         * @param {ConfirmAccountData} confirmAccountData Confirm account data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmAccountV1(confirmAccountData: ConfirmAccountData, options?: any): AxiosPromise<DeleteTopicV1200Response> {
            return localVarFp.confirmAccountV1(confirmAccountData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to confirm changing their own\'s password (from redirected page)
         * @summary Confirm changing your own\'s password
         * @param {ConfirmChangePasswordData} confirmChangePasswordData Confirm change password data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmChangePasswordV1(confirmChangePasswordData: ConfirmChangePasswordData, options?: any): AxiosPromise<DeleteTopicV1200Response> {
            return localVarFp.confirmChangePasswordV1(confirmChangePasswordData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to create a new user
         * @summary Create a new user
         * @param {string} authorization Authorization token
         * @param {CreateUserData} createUserData Create user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserV1(authorization: string, createUserData: CreateUserData, options?: any): AxiosPromise<CreateUserV1200Response> {
            return localVarFp.createUserV1(authorization, createUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to edit another user. Users are not allowed to edit their own information.
         * @summary Edit a user\'s basic information
         * @param {string} authorization Authorization token
         * @param {EditUserData} editUserData Edit user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserV1(authorization: string, editUserData: EditUserData, options?: any): AxiosPromise<EditUserV1200Response> {
            return localVarFp.editUserV1(authorization, editUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a client (with Client-R-ID) to generate a captcha
         * @summary Get a captcha
         * @param {string} clientRID Client-R-ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCaptchaV1(clientRID: string, options?: any): AxiosPromise<GenerateCaptchaV1200Response> {
            return localVarFp.generateCaptchaV1(clientRID, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to get their own information
         * @summary Get the user\'s information
         * @param {string} authorization Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeV1(authorization: string, options?: any): AxiosPromise<GetMeV1200Response> {
            return localVarFp.getMeV1(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to get another user\'s information by their user ID
         * @summary Get a user\'s information
         * @param {string} authorization Authorization token
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoV1(authorization: string, id: string, options?: any): AxiosPromise<GetUserInfoV1200Response> {
            return localVarFp.getUserInfoV1(authorization, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to login to the system and obtain access/refresh tokens
         * @summary Login to the system
         * @param {LoginData} loginData Login data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginV1(loginData: LoginData, options?: any): AxiosPromise<LoginV1200Response> {
            return localVarFp.loginV1(loginData, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to refresh their access token
         * @summary Refresh the access token
         * @param {string} authorization Refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reAuthV1(authorization: string, options?: any): AxiosPromise<ReAuthV1200Response> {
            return localVarFp.reAuthV1(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to search for users
         * @summary Search users
         * @param {string} authorization Authorization token
         * @param {SearchUserData} searchUserData Search user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserV1(authorization: string, searchUserData: SearchUserData, options?: any): AxiosPromise<SearchUserV1200Response> {
            return localVarFp.searchUserV1(authorization, searchUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Allows a user to ban another user
     * @summary Ban a user
     * @param {string} authorization Authorization token
     * @param {BanUserData} banUserData Ban user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public banUserV1(authorization: string, banUserData: BanUserData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).banUserV1(authorization, banUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to change a user\'s password.
     * @summary Change a user\'s password
     * @param {string} authorization Authorization token
     * @param {ChangePasswordData} changePasswordData Change password data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePasswordV1(authorization: string, changePasswordData: ChangePasswordData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).changePasswordV1(authorization, changePasswordData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to confirm their account
     * @summary Confirm account
     * @param {ConfirmAccountData} confirmAccountData Confirm account data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmAccountV1(confirmAccountData: ConfirmAccountData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).confirmAccountV1(confirmAccountData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to confirm changing their own\'s password (from redirected page)
     * @summary Confirm changing your own\'s password
     * @param {ConfirmChangePasswordData} confirmChangePasswordData Confirm change password data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmChangePasswordV1(confirmChangePasswordData: ConfirmChangePasswordData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).confirmChangePasswordV1(confirmChangePasswordData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to create a new user
     * @summary Create a new user
     * @param {string} authorization Authorization token
     * @param {CreateUserData} createUserData Create user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserV1(authorization: string, createUserData: CreateUserData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserV1(authorization, createUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to edit another user. Users are not allowed to edit their own information.
     * @summary Edit a user\'s basic information
     * @param {string} authorization Authorization token
     * @param {EditUserData} editUserData Edit user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUserV1(authorization: string, editUserData: EditUserData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).editUserV1(authorization, editUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a client (with Client-R-ID) to generate a captcha
     * @summary Get a captcha
     * @param {string} clientRID Client-R-ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public generateCaptchaV1(clientRID: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).generateCaptchaV1(clientRID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to get their own information
     * @summary Get the user\'s information
     * @param {string} authorization Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMeV1(authorization: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMeV1(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to get another user\'s information by their user ID
     * @summary Get a user\'s information
     * @param {string} authorization Authorization token
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfoV1(authorization: string, id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserInfoV1(authorization, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to login to the system and obtain access/refresh tokens
     * @summary Login to the system
     * @param {LoginData} loginData Login data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginV1(loginData: LoginData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).loginV1(loginData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to refresh their access token
     * @summary Refresh the access token
     * @param {string} authorization Refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public reAuthV1(authorization: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).reAuthV1(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to search for users
     * @summary Search users
     * @param {string} authorization Authorization token
     * @param {SearchUserData} searchUserData Search user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public searchUserV1(authorization: string, searchUserData: SearchUserData, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).searchUserV1(authorization, searchUserData, options).then((request) => request(this.axios, this.basePath));
    }
}



